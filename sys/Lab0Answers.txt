                    CSC 501 - PA0 additional questions
                    
Name: Aravindhan Dhanasekaran
Unity ID: adhanas

Note: Please use fixed width font (Consolas or Courier New) to view this file.

________________________________________________________________________________

1. Assuming the XINU text begins at address 0x0, draw a rough diagram of XINU's 
memory layout with addresses derived from your experimental measurements. 
Include the information you uncovered from running your version of 
printsegaddress() and printprocstks().

Usually, the memory is organized into different segmnets - text, data, BSS, heap 
and stack. In Xinu, all the processes share the text, data, BSS and heap 
sections, but each process has its own stack space.

To understand Xinu's memory organization better, I created three different 
processes from the main process. Lets call them pA, pB and pC. Based on the 
output generated by printsegaddress() and printprocstks(), Xinu's memory layout 
would be like this.

                                                   pC's SP         pB's SP         pA's SP         main's SP
                                                   0x00ffbf54      0x00ffcf58      0x00ffdf24       0x00ffefa0
                                                      |               |               |                |
                                                      |               |               |                |
                                                      |               |               |                |   
                                                      |               |               |                |
       0x000096b2         0x00013c54        0x00ffaffc|     0x00ffbffc|     0x00ffcffc|     0x00ffdffc |
       (etext - 1)         (end - 1)        pC's limit|     pB's limit|     pA's limit|    main's limit|
           |                   |                |     |         |     |         |     |         |      |
           |                   |                |     |         |     |         |     |         |      |
           |                   |                |     |         |     |         |     |         |      | 
           V                   V                V     V         V     V         V     V         V      V
 +---------+---------+---------+-------+--------+-------+-------+-------+-------+-------+-------+--------+
 |  text   |   data  |   BSS   | heap  |  free  |  pC's |   4   |  pB's |   4   |  pA's |   4   | main's |
 | segment | segment | segment | space | memory | stack | bytes | stack | bytes | stack | bytes | stack  |
 +---------+---------+---------+-------+--------+-------+-------+-------+-------+-------+-------+--------+
 ^                   ^                                  ^               ^               ^                ^
 |                   |                                  |               |               |                |
 |                   |                                  |               |               |                |
 |                   |                                  |               |               |                |
start            (edata - 1)                        pC's base       pB's base       pA's base        main's base
0x00000000       0x0000b5b8                         0x00ffbff8      0x00ffcff8      0x00ffdff8       0x00ffeff8

Reference:
1. Output of printsegaddress()
2. Output of printprocstks() with four processes - main, pA, pB and pD.
3. Text book (Operating System Design: The Xinu Approach)

________________________________________________________________________________

2. What is the difference in stack top address before and after calling printtos()? 
Draw a diagram to illustrate what are the contents of the items pushed into the 
stack between these two time points.

Going by the output of printtos() we have,
Top of stack before calling printtos() : 0x00ffefc0
Top of stack after calling printtos()  : 0x00ffefb8

Difference = 0x8 bytes. The 8 bytes accounts for return address of the caller.
   1. The return address of the caller (contents of the EIP register). In our 
      case, that would be that of main()'s. The 'call' instruction implicity 
      pushes the return address onto the stack.
   2. Frame pointer of the caller. This will be done explicitly by the callee.
      In our case, this would be done by printtos(). In fact, this would be the
      first instruction that printtos() would execute. 
      
      This can be illustrated by looking at the assembly code of printtos().
      printtos.o:     file format elf32-i386

      Disassembly of section .text:

      00000000 <printtos>:
         0:	55                   	push   %ebp
         1:	89 e5                	mov    %esp,%ebp
         /* more printtos() code */
         
                     |                 |
                     |  main()'s last  |0x00ffefd0
                     |  stack content  |<== ToS before entering printtos()
                     +-----------------+
                     |  return address |0x00ffefcc
                     |    of main()    |
                     +-----------------+
                     |       EBP       |0x00ffefc8
                     |    of main()    |<== ToS after entering printtos()
                     +-----------------+
                     |   printtos()    |0x00ffefb0
                     |     local       |<== ToS after pusing local vairables
                     |    variables    |
                     |                 |

       Fig: Contents of a stack during function invocation
________________________________________________________________________________

3. Which byte order is adopted in the host machine that we are using? How did 
you find out? 

The host machine follows little endian byte ordering.

In case of little endian byte ordering, the least significant byte is stored at
the smallest memory location. In big endian byte ordering, the MSB is stored at
the smallest memory location.

Eg., Hex value 0x0101 will be stored as (memory grows from right to left):
Little endian: 00000000 00000001 00000000 00000001
Big endian:    00000001 00000000 00000001 00000000

This can be easily figured out by writing a simple program.
#include <stdio.h>

int
main(int argc, char *argv)
{
    int integer = 0x0101;

    if (1 == (*(char *) (&integer))) {
        printf("Little endian\n");
    } else {
        printf("Big endian\n");
    }   
    return 0;
}

________________________________________________________________________________

4. Briefly describe the mov, push, pusha, pop, and popa instructions in the x86.

mov:
It is a data transfer instruction. It can be used to move data between
the source and destination. 
Syntax: mov src, dest
src can be a register, memory location or a value (immediate)
dst can be either a register or a memory location
Examples:
mov %eax, %ebx # moves the contents of eax to ebx
mov $9, %ebx   # moves 9 to ebx

push:
It pushes the given argument onto the stack. The stack pointer is decremented 
first and then the argument is moved to the stack.
Syntax: push argument
Examples:
push %eax  # decrements stack pointer by 4 and pushes the content of eax onto stack
push $18   # decrements stack pointer by 4 and pushes 18 onto stack

pusha:
It pushes the contents of all the general purpose registers onto the stack in
the following order: EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI. The stack pointer 
is updated accordingly.
Syntax: pusha

pop:
It removes the top most elment from the stack and puts it in the location 
pointed by the given argument. It increments the stack pointer accordingly.
Syntax: ppo argument
Examples:
pop %eax  # remvoves the top most element of stack and loads eax with that value

popa:
This is same as 'pusha', but this simply pops (similar to 'pop' instruction). 
This usually complements 'pusha' instruction.
Syntax: popa

Reference: http://en.wikibooks.org/wiki/X86_Assembly

________________________________________________________________________________

5. In a stack frame, local variables are stored below the top of the stack. 
In task 3, does your result show all the local variables declared in your 
printtos function? If not, can you explain that? (hint: try to disable the 
compiler optimization by specifing -O0 in your Makefile)

With compiler optimization enabled in the Makefile, printtos() will not print
the contents of the locally defined variables unless the variable is used in
the code.

For example, consider the following code snippet:
void
printtos()
{
    int a = 0xaaaa;
    int b = 0xbbbb;
    
    /* other printtos code without using a & b anywhere */
    
    return;
}
Since the local variables are not used anywhere, the compiler optimizes the code
by not pushing the local varaibles on the stack, thereby saving memory.

But, if we either disable optimizations in the Makefile or modify the printtos()
code to use the local variables, compiler would push them onto the stack.

For example, consider the following code snippet:
void
printtos()
{
    int a = 0xaaaa;
    int b = 0xbbbb;
    
    a = a + b;

    /* other printtos code */
    
    return;
}
In this case, the compiler will push the local values onto the stack and thus
printtos() would print them.

________________________________________________________________________________

